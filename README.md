- [x] синхронная валидация одного поля (пример - минимальная длина поля)
- [ ] асинхронная валидация одного поля (пример - проверка на сервере занято ли имя пользователя)
- [ ] синхронная валидация всей формы, ошибка присваивается конкретному полю (пример: пароль - повторение пароля)
- [ ] асинхронная валидация всей формы, ошибка присваивается конкретному полю (пример: предварительная проверка - извините, ваш тариф не позволяет создание такого количества узлов)
- [ ] асинхронная валидация всей формы, ошибка присваивается всей форме

# Синхронная валидация одного поля

## Пример

```javascript
import { createValidationService } from "xstate-form-validation";

const { service, register } = createValidationService({ rules });
const input = document.createElement('input');

register(input)

service.onTransition((state) => {
    if (state.matches('valid') {
       input.classlist.remove('invalid');
    }
    if (state.matches('invalid')) {
      input.classlist.add('invalid');
    }

});

```

## `createValidationService(config)`

Устанавливает правила проверки в контекст машины интерпретирует ее и стартует.

`config.rules` - массив функций-правил для проверки проверки

### Возвращает:

```javascript
{
  service,
  register, 
  updateRules,
  validate,
  machine,
}
```

### `service` - интерпретированный сервис для машины
### `register(input)` - функция для установки обработчика - валидатора на инпут
### `updateRules(rules, value)` - функция для обновления правил проверки
### `validate(value)` - функция для валидации значения
### `machine` - машина

## Описание
Для валидации поля его нужно зарегистрировать, с помощью функции `register`, на вход передать `HTMLInputElement` который нужно валидировать. 
### Синтаксис

```javascript
register(input)
```
### Параметры
`input` - HTMLInputElement ввод которого нужно валидировать

Для отображения текущего состояния использовать  `service.onTransition` 

### Синтаксис

```javascript
service.onTransition(callback);
```

### Параметры
`callback` - функция вызывающаяся при изменении состояния, принимает на вход 1 аргумент - текущее состояние: [state](https://xstate.js.org/api/classes/state.html). Для проверки, что текущее состояние валидно, можно использовать `state.matches('valid')`, а что состояние не валидно - `state.matches('invalid')`. Текст ошибки, при наличии - `state.context.error`
Для синхронной валидации используются функции - правила проверки введенного значения. Если правило возвращает значение отличное от true, тогда валидация считается не пройденной, если из функции возвращается строка, она будет сохранена в контексте и может быть использована ~~против вас~~ в качестве сообщения об ошибке.

Стейт машина имеет 4 состояния: начальное, валидация, валидное и не валидное, для перехода в состояние валидации необходимо отправлять событие `VALIDATE`:

```javascript
{
  type: "VALIDATE",
  value: e.target.value
}
```

- `value` - значение поля

Валидация реализована в виде функции возвращающей промис, если валидация "прошла" промис резолвится, если нет - отклоняется. Описание ошибки валидации хранится в контексте, так же как и массив функций - правил валидации.

## Ограничения

1) При динамическом формировании правил проверки, для обновления набора правил в контексте машины необходимо использовать функцию `updateRules`. 
    ### Синтаксис

    ```javascript
    updateRules(rules, value)
    ```
    ### Параметры
    - `rules` - массив функций - валидаторов
    - `value` - текущее значение для валидации по новым правилам
    
    Изначально я рассматривал вариант, когда правила передаются в функцию валидации, но в таком случае валидация происходит снаружи библиотеки

2) Валидация происходит сразу по событию `input`, необходимо добавить различные сценарии валидации, но при этом эти сценарии все равно будут ограничены.

## Почему выбрано такое решение

1) Для удобства работы с машиной ее удобно интерпретировать, поэтому я решил экспортировать функцию, которая сразу интерпретирует сервис и запускает его и возвращает его и нужные функции
2) Т.к. у нас библиотека для валидации, мы хотим просто описывать как валидировать, поэтому обработчик в котором происходит валидация устанавливается внутри библиотеки.
3) Функция `register` вынесена отдельно для возможности вешать обработчики на поля, которых еще нет на странице
